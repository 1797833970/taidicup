# 问题四：生产线排班方案优化

详情可见[生产线排班方案（线性规划）.pdf](生产线排班方案（目标规划）.pdf)

## 问题描述

问题四本质是目标规划问题，要求基于问题三的规律和结论以及给出的约束条件，对生产线和人员进行合理配置。
求解思路:大目标转化为多个小目标，将问题转化为给42名员工和10天生产线制定7天的排班。因满足条件的7天排班有许多种，后续排班不需要周期性重复这7天的排班覆盖整个年度的排班，可进行不断的调换，满足排班的公平性。

## 解决方案

### 1. 排班方案

所有可能的休息-工作模式（7天中工作5天，休息2天）：

```python
def generate_01_strings(ones, zeros, total_length):
    # 生成所有可能的1的位置组合
    all_positions = list(range(total_length))
    valid_combinations = combinations(all_positions, ones)
    binary_strings = []
    # 生成所有符合条件的二进制串
    for combo in valid_combinations:
        strings = ''.join('1' if i in combo else '0' for i in range(total_length))
        binary_strings.append(strings)

    # 要删除的元素列表（不合理的排班模式）
    elements_to_remove = ['1010111', '0101111', '1111010', '1110101', '1101011', '1011101', '1011011', '1101101','0111101','1011110']
    binary_strings = [s for s in binary_strings if s not in elements_to_remove]

    # 添加特定值的元素（合理的排班模式）
    binary_strings.extend(['0011111', '1100111','1110011', '1111100','1001111', '1111001','1001111', '1111001','0011111','1111100'])

    random.shuffle(binary_strings)
    return binary_strings
```

### 2 班次分配

将工作日分配为早班（1）、中班（2）、晚班（3）：

```python
def get_worker_schedule(strings_01):
    work_list = strings_01*2
    random.shuffle(work_list)
    worker_schedule = []
    for s in work_list:
        split_list = [ int(s[i]) for i in range(len(s))]
        worker_schedule.append(split_list)
    worker_schedule = np.array(worker_schedule).T
    return worker_schedule

def get_worker_schedule_123(worker_schedule):
    matrix = worker_schedule.copy()
    yesterday = []
    # 对每行进行操作
    for i, row in enumerate(matrix):
        # 找出1的位置
        ones_positions = np.where(row == 1)[0]
        # 找出前一天3的位置
        yesterday_three_positions = np.where(row == 3)[0]

        # 选择10个前一天不为3的位置替换为1（早班）
        remaining_ones = list(set(ones_positions) - set(yesterday_three_positions))
        to_replace_one = np.random.choice(remaining_ones, size=10, replace=False)
        matrix[i, to_replace_one] = 1

        # 选择10个位置为2（中班）
        remaining_twos = list(set(ones_positions) - set(to_replace_one))
        to_replace_two = np.random.choice(remaining_twos, size=10, replace=False)
        matrix[i, to_replace_two] = 2

        # 选择10个位置为3（晚班）
        remaining_threes = list(set(ones_positions) - set(to_replace_one) - set(to_replace_two))
        to_replace_three = np.random.choice(remaining_threes, size=10, replace=False)
        matrix[i, to_replace_three] = 3

        yesterday = matrix[i]
    return matrix
```

### 3 排班结果

确保每天每个班次的人员数量在合理范围内：
```python
np.random.seed(0)  # 为了可重现的结果

while True:
    strings_01 = generate_01_strings(5,2,7)
    worker_schedule = get_worker_schedule(strings_01)
    matrix = get_worker_schedule_123(worker_schedule)
    
    # 统计每列1, 2, 3的个数
    counts = np.array([[np.sum(matrix[:, j] == i) for i in range(1, 4)] for j in range(matrix.shape[1])])
    
    # 找出不符合条件的
    rows_with_45 = np.any((counts>3) , axis=1)
    rows_with_0 = np.any((counts == 0) , axis=1)

    # 如果符合条件，退出循环
    if (len(counts[rows_with_45]) == 0) & (len(counts[rows_with_0]) < 5) :
        break
```
生成的排班表包含42名员工（B001-B042），共7天的排班安排：

| 日期 | B001 | B002 | B003 | ... | B041 | B042 |
|------|------|------|------|-----|------|------|
| 1 | 中 | 晚 | 中 | ... | 中 | 中 |
| 2 | 休 | 休 | 晚 | ... | 中 | 中 |
| 3 | 休 | 休 | 早 | ... | 休 | 休 |
| 4 | 晚 | 早 | 休 | ... | 早 | 早 |
| 5 | 中 | 中 | 休 | ... | 晚 | 晚 |
| 6 | 早 | 中 | 早 | ... | 中 | 晚 |
| 7 | 早 | 晚 | 早 | ... | 休 | 休 |

其中：
- 0 = 休（休息） / 1 = 早（早班） / 2 = 中（中班） / 3 = 晚（晚班）
- **221模式**：21人
- **311模式**：19人
- **320模式**：2人

### 4. 优化目标 （目标规划模型）

#### 决策变量

设 $x_{i,j,k}$ 为第 $i$ 个员工在第 $j$ 天第 $k$ 个班次是否工作的二元变量：
- $x_{i,j,k} = 1$：员工 $i$ 在第 $j$ 天第 $k$ 班次工作
- $x_{i,j,k} = 0$：员工 $i$ 在第 $j$ 天第 $k$ 班次休息

其中：
- $i = 1, 2, ..., 42$（员工编号）
- $j = 1, 2, ..., 7$（天数）
- $k = 1, 2, 3$（班次：1=早班，2=中班，3=晚班）

#### 目标函数

最大化总产量：

$$
\max Z = \sum_{i=1}^{42} \sum_{j=1}^{7} \sum_{k=1}^{3} w_i \cdot x_{i,j,k}
$$

其中 $w_i$ 为员工 $i$ 的生产能力系数，基于问题三的工龄分析结果：
- 工龄2年：$w_i = 1.0$（基准）
- 工龄1年：$w_i = 0.95$
- 工龄3年：$w_i = 0.90$
- 工龄6年：$w_i = 0.85$

#### 约束条件

#### （1） 工作天数约束

每个员工每周工作5天：

$$
\sum_{j=1}^{7} \sum_{k=1}^{3} x_{i,j,k} = 5, \quad \forall i
$$

#### （2） 班次人数约束

每天每个班次的人员数量要求：

$$
L_k \leq \sum_{i=1}^{42} x_{i,j,k} \leq U_k, \quad \forall j, k
$$

其中 $L_k$ 和 $U_k$ 分别为第 $k$ 个班次的最低和最高人数要求。

#### （3） 连续工作约束

员工不能连续工作超过3天：

$$
\sum_{t=j}^{j+2} \sum_{k=1}^{3} x_{i,t,k} \leq 3, \quad \forall i, \forall j \leq 5
$$

#### （4） 晚班约束

避免员工连续上晚班：

$$
x_{i,j,3} + x_{i,j+1,3} \leq 1, \quad \forall i, \forall j \leq 6
$$

#### （5） 工龄平衡约束

每个班次工龄2年的员工数量：

$$
\sum_{i \in S_2} x_{i,j,k} \geq 1, \quad \forall j, k
$$

其中 $S_2$ 为工龄2年的员工集合。

### 5. 求解过程
本质上这是一个 指派问题（Assignment Problem），用 线性规划 + 整数变量 ，把 10 个人分配到 10 条生产线，使总产量最大化
```python
def maximize_production(abilities):
    # 人数和生产线数
    n = 10
    
    # 创建一个线性规划问题，我们希望最大化目标函数
    prob = pulp.LpProblem("Maximize Production", pulp.LpMaximize)
    
    # 决策变量：x[i][j] 表示第 i 个人是否分配到第 j 条生产线，是则为1，否则为0
    x = pulp.LpVariable.dicts("Worker_Assignment", (range(n), range(n)), cat='Binary')
    
    # 目标函数：最大化总产量
    prob += pulp.lpSum(abilities[i][j] * x[i][j] for i in range(n) for j in range(n))
    
    # 约束条件：每个人只能分配到一条生产线
    for i in range(n):
        prob += pulp.lpSum(x[i][j] for j in range(n)) == 1
    
    # 约束条件：每条生产线只能分配1个人
    for j in range(n):
        prob += pulp.lpSum(x[i][j] for i in range(n)) == 1
    
    # 求解线性规划问题
    prob.solve()
    
    # 输出结果
    print("Maximum sorce", pulp.value(prob.objective))
    
    # 创建一个10行10列的全0矩阵
    allocation = np.zeros((10, 10), dtype=int)

    # 遍历外层字典的每个项
    for i, inner_dict in x.items():
        # 遍历内层字典的每个项
        for j, variable in inner_dict.items():
            # 检查内层字典的变量的值是否为1
            if variable.value() == 1:
                # 如果是，则将i和j作为键添加到allocation字典中
                allocation[i][j] = 1
            
    return allocation
```